---
import type { Time } from '@/lib/utils'

import { Image } from 'astro:assets'

import Boss from '@/components/Boss.astro'
import DamageInfo from '@/components/DamageInfo.astro'
import DotInfo from '@/components/DotInfo.astro'
import RoleIcon from '@/components/RoleIcon.astro'
import Span from '@/components/Span.vue'
import Bleeding from '@/components/buff/Bleeding.astro'
import MagicVulnerabilityUp from '@/components/buff/MagicVulnerabilityUp.astro'
import MechanicSection from '@/components/section/MechanicSection.astro'
import SolutionSection from '@/components/section/SolutionSection.astro'
import ImageRow from '@/components/typography/ImageRow.astro'
import ToggleSwitch from '@/components/ToggleSwitch.astro'


import StratBoard from '@/components/StratBoard.astro'

import Badge from '@/components/Badge.astro'
import CastSection from '@/components/section/CastSection.astro'

import Zelenia from './Zelenia.astro'




---
<SolutionSection>
  <h4 class="mt-8 text-2xl">
    <Span variant="lime">动态演示</Span>
  </h4>
  
  <div class="flex gap-4">
    <div class="flex shrink flex-col items-center gap-4">
      <StratBoard
        width={312}
        height={312}
        key="rose-blood-3-solution-dynamic"
        class="max-h-78 max-w-78"
        canvasClass="h-full w-full border-2 border-amber-800/75 dark:border-amber-100"
      />
      <div
        class="flex items-center justify-start gap-2 rounded-full border border-lime-200 bg-lime-100/90 px-3 py-1 backdrop-blur-sm dark:border-lime-800/80 dark:bg-lime-900/80 dark:shadow-lime-900/30"
      >
        <button
          id="solution-dynamic-play-button"
          class="group flex items-center gap-2"
          title="开始演示"
        >
          <div
            class="flex h-6 w-6 items-center justify-center rounded-full bg-lime-500 text-white shadow-inner shadow-lime-400/30 transition-all group-hover:scale-110 group-hover:bg-lime-600 group-hover:shadow group-active:scale-95 dark:bg-lime-600 dark:shadow-lime-500/10 dark:group-hover:bg-lime-500"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="ml-0.5 h-4 w-4"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
          </div>
          <span
            class="text-sm font-medium text-lime-900 transition-all group-hover:scale-110 group-hover:text-lime-700 group-active:scale-95 dark:text-lime-100 dark:group-hover:text-white"
            >开始演示</span
          >

        </button>
        <div class="paragraph">
          <ToggleSwitch id="stell-moon-switch"
            lVariant="yellow"
            rVariant="pink"
            lLabel="先钢铁"
            rLabel="先月环" />
        </div>
      </div>
    </div>
    

  </div>
</SolutionSection>


<script>
  // 1. 类型和第三方库引用
  import type { Application } from 'pixi.js'
  import { AnimatedSprite, Assets, Container, Graphics, Sprite, Texture } from 'pixi.js'
  import { animate } from 'motion'
  import { listenKeys } from 'nanostores'

  // 2. 业务相关自定义库
  import type { RoleType } from '@/lib/role'
  import { Role } from '@/pixi/role'
  import { getScale, YmToPx ,YmToPxMap} from '@/pixi/utils'
  import { setWaymark } from '@/pixi/waymark'
  import { $stratBoards } from '@/stores/stratBoards'
  // import { waymarkData } from '../_data/waymark'
  // import { $roleOrders, shuffleRoleOrder } from '../_stores/getDownOrder'

  // 3. 配置常量
  // const roleTypeMap = { ... }
  // const radianMap = { ... }
  const ratio = 1.25
  const circleRadius = 8 * YmToPx * ratio
  // 其他动画参数...

  // 4. 状态变量
  
  let removeTickerFn = null
  let removeAnimFn = null
  let skillOrder = "steelFirst";

  // ==================== 新增：技能扇形角度配置 =======================
  // 共三组，每组是60°扇区+180°同宽扇区
  const fanConfigs = [
    // { id: 0, angles: [ {start:60, end:120}, {start:150, end:210} ] },
    // { id: 1, angles: [ {start:120, end:180}, {start:210, end:270} ] },
    // { id: 2, angles: [ {start:0, end:60}, {start:270, end:330} ] },
    { id: 0, angles: [ {start:60, end:120}] },
    { id: 1, angles: [ {start:120, end:180}] },
    { id: 2, angles: [ {start:0, end:60}] },
  ];
  // 动画释放顺序，动态可变
  let fanOrder = [0,1,2]; // 可根据实际场次顺序指定

  // 场地圆环半径
  const innerR = 5 * YmToPx * ratio;
  const outerR = 10 * YmToPx * ratio;

  const innerA = innerR/2
  const outerA = outerR/2

  // ==================== 新增：绘制圆环和扇形的函数 =======================

  // 工具：度转弧度
  function deg2rad(d: number) { return d * Math.PI / 180; }

  // 绘制1个扇形(环形片段, 支持覆盖内外半径)
  function drawPie(
    g: Graphics,
    startDeg: number,
    endDeg: number,
    r1: number,
    r2: number,
    color: number = 0xffff00,
    alpha: number = 0.6
  ): void {
    const startDeg2 = startDeg + 180
    const endDeg2 = endDeg + 180

    console.log("drawPie: start")
    g.clear();

    g.moveTo(0, 0);
    g.arc(0,0,r2, deg2rad(startDeg), deg2rad(endDeg));
    g.closePath();
    g.fill({ color, alpha });

    g.moveTo(0, 0);
    g.arc(0,0,r2, deg2rad(startDeg2), deg2rad(endDeg2));
    g.closePath();
    g.fill({ color, alpha });
    
  }

  function drawRing2(
    g: Graphics,
    r1: number,
    r2: number,
    color: number = 0xffff00,
    alpha: number = 0.6,
    startDeg: 0,
    endDeg: 360,
  ): void {
    console.log("drawPie: start")
    g.clear();
    
    g.moveTo(r1 * Math.cos(deg2rad(startDeg)), r1 * Math.sin(deg2rad(startDeg)));
    g.arc(0,0,r2, deg2rad(startDeg), deg2rad(endDeg));
    g.lineTo(r1 * Math.cos(deg2rad(endDeg)), r1 * Math.sin(deg2rad(endDeg)));
    g.arc(0,0,r1, deg2rad(endDeg), deg2rad(startDeg), true);
    g.closePath();
    g.fill({ color, alpha });
  }

  // 绘制满圆环(钢铁/月环)
  function drawRing(
    g: Graphics, 
    r1: number,
    r2: number, 
    color=0x3388ff, 
    alpha=0.6
  ) : void {
    g.clear();

    // 外圆
    g.moveTo(r2, 0);
    g.arc(0, 0, r2, 0, Math.PI * 2);

    // 连到内圆
    g.moveTo(r1, 0);
    g.arc(0, 0, r1, 0, Math.PI * 2, true);

    g.closePath();
    g.fill({ color, alpha });
  }

  // ==================== 新增：扇形组实例 ========================
  let bossFanGs: Graphics[] = []; // [Graphics, Graphics, Graphics]
  let steelG: Graphics;
  let moonG: Graphics;
  

  // ==================== 新增：初始化技能扇形图层函数 ===============
  function initSkillGraphics(container: Container) {
    // 移除旧的
    bossFanGs.forEach(g => g.destroy && g.destroy());
    bossFanGs = [];
    if (steelG) steelG.destroy();
    if (moonG) moonG.destroy();

    // 三组黄色扇形（默认隐藏）
    for(let i=0; i<3; i++) {
      const g = new Graphics();
      g.position.set(0,0);
      g.visible = false;
      container.addChild(g);
      bossFanGs.push(g);
    }
    // 钢铁、月环是蓝色
    steelG = new Graphics(); steelG.visible = false; container.addChild(steelG);
    moonG = new Graphics(); moonG.visible = false; container.addChild(moonG);
    
    console.log("initSkillGraphics ok")
  }

  // 5. 初始化舞台和角色
  async function initFloorContainer(container: Container) {
    // 加载地板图片、draw地图、放waymark
    const squareMask = new Graphics()
    const width = 25 * YmToPx
    // 你的mask定义，保持不变
    squareMask.rect(-width / 2 + 0.01 * YmToPxMap[50], -width / 2 + 0.01 * YmToPxMap[50], width, width)
    squareMask.fill({ color: 'white' })
    container.mask = squareMask
    container.addChild(squareMask)

    // 加载图片
    const floorTexture = await Assets.load('07/zelenia/RoseBlood_floor_2.png')
    const floor = Sprite.from(floorTexture)
    floor.anchor.set(0.5, 0.5)
    
    // 计算适应mask的缩放
    // 宽高一致用 width，否则用 min 宽高
    const imgW = floorTexture.width
    const imgH = floorTexture.height
    // “mask区域实际宽度”就是 width
    const maskSize = width
    // 按比例缩放层图片以适应mask正方形区域
    const scale = Math.min(maskSize / imgW, maskSize / imgH)
    floor.scale.set(scale)
    
    // 位置设为 mask 中心（你的mask也是以(0,0)为中心）
    floor.position.set(0, 0)
    
    container.addChild(floor)

    // await setWaymark(container, waymarkData, 0.5)

    console.log('ratio:', ratio);
    container.scale.set(ratio);
}


  // 6. 初始化角色
  async function initPlayerContainer(container: Container) {
    // 生成Role小人，设置初始位置
  }

  // 7. 定义主播放动画过程
  async function play() {
    // 资源加载和动画流程
    // 按当前 $roleOrders 的顺序移动角色/显示特效
    showBossSkills();
  }

  // 8. 重置角色
  // async function resetRoles(roles, anim = false) {
  //   // 所有角色归初始位置，可选动画
  // }

  // 9. 按钮事件处理
  document.getElementById('solution-dynamic-play-button')
    ?.addEventListener('click', () => {
      play()
    })
  document.getElementById('solution-dynamic-random-button')
    ?.addEventListener('click', () => {
      // shuffleRoleOrder()
      play()
    })
  document.getElementById('stell-moon-switch')
    ?.addEventListener('change', function () {
      const checkbox = this as HTMLInputElement;
      if (checkbox.checked) {
        skillOrder = "moonFirst";
      } else {
        skillOrder = "steelFirst";
      }
      console.log('skillOrder:', skillOrder);
  })

  // 10. 监听StratBoard画布实例变化，根据画布初始化舞台一次
  listenKeys($stratBoards, ['rose-blood-3-solution-dynamic'], async (stratBoards) => {
    // 获取app和container，初始化地板和角色
    // 可加移除旧动画ticker、清理引用等
    // 自动play一次（可以可选）
    // 取出 app 和 container
    const app = stratBoards['rose-blood-3-solution-dynamic']
    const floorContainer = new Container()
    floorContainer.position.set(app.screen.width / 2, app.screen.height / 2)

    // 初始化地板和mask
    await initFloorContainer(floorContainer)   // 只初始化地板

    // 初始化技能图层，确保在地板之上
    initSkillGraphics(floorContainer)

    // 最后加到舞台
    app.stage.addChild(floorContainer)
    console.log(floorContainer.children)



  })

  // ==================== 新增：播放boss技能的流程动画 =======================

  // 用于当前播放序号
  let currentAnimIdx = 0;
  let removeSkillAnim = null;


  function showBossSkills(){
    
    console.log("showBossSkills: start")
    // 必须有 bossFanGs/steelG/moonG
    bossFanGs.forEach(g=>{g.visible=false; g.clear()});
    steelG.visible = false; steelG.clear();
    moonG.visible = false; moonG.clear();

    currentAnimIdx = 0;

    // 动态顺序，fanOrder 可自定义
    function playFanStep(i: number){
      if(i>=fanOrder.length) {
        // 结束时清理
        setTimeout(()=> {
          bossFanGs.forEach(g=>g.visible=false);
          steelG.visible=false; moonG.visible=false;
        }, 1000);
        return;
      }
      let idx = fanOrder[i];
      bossFanGs.forEach(g=>{g.visible=false; g.clear()}); // 只显示当前
      const conf = fanConfigs[idx];
      let g = bossFanGs[idx];
      g.position.set(0,0);
      // 橙黄色扇形（技能1）
      conf.angles.forEach(a=>drawPie(g, a.start, a.end, innerR, outerR, 0xffcc00, 0.8));
      g.visible = true;

      console.log(skillOrder)

      // 钢铁（第一次释放才有内圆）：蓝色
      if(i===0){
        if(skillOrder === "steelFirst") {
          steelG.visible = true;
          drawRing(steelG, 0, innerR, 0x3388ff, 0.5);
          moonG.visible = false; moonG.clear();
        }
        else
        {
          moonG.visible = true;
          drawRing2(moonG, innerR, outerR, 0x3388ff, 0.6, 0, 360);
          steelG.visible = false; steelG.clear();
        } 
      } 
      // 月环（第二次释放出现环）
      if(i===1){
        if(skillOrder === "steelFirst") {
          moonG.visible = true;
          drawRing2(moonG, innerR, outerR, 0x3388ff, 0.6, 0, 360);
          steelG.visible = false; steelG.clear();
        }
        else
        {
          steelG.visible = true;
          drawRing(steelG, 0, innerR, 0x3388ff, 0.5);
          moonG.visible = false; moonG.clear();
        }
      }
      if(i===2)
      {
        steelG.visible = false; steelG.clear();
        moonG.visible = false; moonG.clear();
      }

      // 2秒后消失并到下一个
      removeSkillAnim = setTimeout(() => {
        g.visible = false; g.clear();
        playFanStep(i+1);
      }, 2000);
    }

    playFanStep(0);
  }

  // ==================== 新增：监控舞台和重置动画 ====================

  listenKeys($stratBoards, ['solution-dynamic'], async (stratBoards) => {
    // ...获取app & container等
    // 可以自动运行一次
    // play();
    // fanOrder = [...]; //可在外部配置当前场次释放顺序
    // 若换顺序需刷新bossFanGs等实例
  })

  // ==================== 清理动画定时器 ====================

  if(removeSkillAnim) clearTimeout(removeSkillAnim);


</script>

